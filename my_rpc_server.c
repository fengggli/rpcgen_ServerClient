/*
 * this is sample code generated by rpcgen.
 * These are only templates and you can use them
 * as a guideline for developing your own functions.
 */

#include "my_rpc.h"
#include <time.h>
#include <dirent.h>
#include <stdio.h>

/* 
 * function 1 get the server time
 */
char **
gettime_1_svc(void *argp, struct svc_req *rqstp)
{
	static char * result;

	/*
	 * insert server code here
	 */
    time_t thetime = time(0);
    result = ctime(&thetime);
    return &result;
}


/* 
 * function 2
 * merge two list
 */
intlist *
merge_1_svc(coupled_int_list *argp, struct svc_req *rqstp)
{
	static intlist  result;
    
	/*
	 * insert server code here
	 */

    result = NULL;

    intlist a = argp->a;
    intlist b = argp->b;

    intlist p, head;
    // result
    intlist result_tail = NULL;
    intlist result_head = NULL;

    // try to merge two list
    for(p=a; p != NULL; p = p->next){
        // get a new node

        intnode* tmp =  (intnode*)malloc(sizeof(intnode));
        // copy the content
        tmp->v = p->v;
        tmp->next = NULL;
        // if this this is the first node
        if(result_tail == NULL){
            result_tail=tmp;
            result_head = tmp;
        }else{
            result_tail->next = tmp;
            result_tail = tmp;
        }
    }
    for(p=b; p != NULL; p = p->next){
        // get a new node

        intnode* tmp =  (intnode*)malloc(sizeof(intnode));
        // copy the content
        tmp->v = p->v;
        tmp->next = NULL;
        // if this this is the first node
        if(result_tail == NULL){
            result_tail=tmp;
            result_head = tmp;
        }else{
            result_tail->next = tmp;
            result_tail = tmp;
        }
    }
    result = result_head;


        
	return &result;
}

/* 
 * function 3
 * reverse user input
 */
char **
reverse_1_svc(char **argp, struct svc_req *rqstp)
{
	static char * result;
    int i = 0;
    int length=0;

	/*
	 * insert server code here
	 */
    static char reversed[101];

    // get the length first
    while((*argp)[i]!='\n')
        i++;
    length = i;

    //now reverse
    for(i = 0; i< length; i++)
        reversed[i] = (*argp)[length -1 - i];

    reversed[i] = '\n';
    result = reversed;
	return &result;
}

/* 
 * function 4
 * read all the entries in a directory
 * code is original from here:
    https://docs.oracle.com/cd/E19683-01/816-1435/6m7rrfn7f/index.html 
 */

char **
readdir_1_svc(char **argp, struct svc_req *rqstp)
{
    static char *result;
    char *tmp = (char *)malloc(sizeof(char)*300);
    DIR           *d;
    struct dirent *dir;
    d = opendir(*argp);
    if(d == NULL){
        sprintf(tmp,"directory \"%s\" doesn't exist",*argp);
    }

    else{

        sprintf(tmp,"the files in directory \"%s\":\n",*argp);
        while (dir = readdir(d))
        {
            sprintf(tmp+ strlen(tmp),"%s\n", dir->d_name);
        }
        closedir(d);
    }
    result = tmp;
    return &result;
}


/*
 * function 5
 * add two matrix and return the integer sum
 */
matrix *
addmatrix_1_svc(coupled_matrix *argp, struct svc_req *rqstp)
{
	static matrix  result;

    matrix *pa, *pb;
    pa = &(argp->a);
    pb = &(argp->b);



	/*
	 * insert server code here
	 */

    int d1, d2, i;
    if(pa->d1!= pb->d1 || pa->d2!=pb->d2)
        return NULL;
    // get the dimension
    d1 = pa->d1;
    d2 = pa->d2;

    // get data allocation
    int *pdata = (int *)malloc(sizeof(int)*d1*d2);
    if(pdata == NULL){
        return NULL;
    }

    // add them up
    int index = 0;
    for(i = 0; i< d1*d2; i++){
            pdata[i] = pa->data.data_val[i]+pb->data.data_val[i];
    }

    result.data.data_len = d1*d2;
    result.data.data_val = pdata;
    result.d1 = d1;
    result.d2 = d2;
	return &result;
}
